{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cliffy","text":""},{"location":"#cliffy","title":"Cliffy","text":"<p>Build feature-rich Python CLIs  quickly.</p> <p>Simplest example</p> <ol> <li> <p>Define a manifest <pre><code># hello.yaml\nname: hello\nversion: 0.1.0\nhelp: Hello world!\n\ncommands:\n  shell: $echo \"hello from shell\"\n  python: print(\"hello from python\")\n</code></pre></p> </li> <li> <p>Load CLI <pre><code>$ cli load hello.yaml\n</code></pre> <code>hello.yaml</code> automatically gets parsed to generate a Typer CLI and gets loaded into the running Python environment.</p> </li> <li> <p>Run CLI directly</p> </li> </ol> <p></p> <p>For more examples, check examples directory.</p> <p>Build into single-file executable</p> <p>Simple todo CLI with sqlite3 + tabulate.</p> <pre><code># todo.yaml\nname: todo\nversion: 1.0.0\nrequires:\n   - tabulate  # For pretty table output\n   - rich      # For colored terminal output\nimports: |\n  import sqlite3\n  from pathlib import Path\n  from tabulate import tabulate\n  from rich import print\n\ncommands:\n  create:\n    help: Create a new database with tasks table\n    params:\n    - name: str = typer.Option(..., prompt=True, confirmation_prompt=True)\n    run: |\n      db_path = Path(f\"{name}.db\")\n      conn = sqlite3.connect(db_path)\n      conn.execute(\"CREATE TABLE tasks (id INTEGER PRIMARY KEY, task TEXT NOT NULL, done BOOLEAN NOT NULL)\")\n\n      # insert example tasks\n      conn.execute(\"INSERT INTO tasks (task, done) VALUES ('Fight for your right!', 0)\")\n      conn.execute(\"INSERT INTO tasks (task, done) VALUES ('To party!', 1)\")\n      conn.commit()\n      conn.close()\n      print(f\"\u2728 Created database {db_path} with tasks table\")\n\n  tasks:\n    help: List tasks in database\n    params: [name: str!]\n    run: |\n      conn = sqlite3.connect(f\"{name}.db\")\n      cursor = conn.execute(\"SELECT * FROM tasks\")\n      tasks = cursor.fetchall()\n      conn.close()\n      print(tabulate(tasks, headers=['ID', 'Task', 'Done'], tablefmt='grid'))\n\n  add:\n    help: Add a new task\n    params: [name: str!, task: str!]\n    run: |\n      conn = sqlite3.connect(f\"{name}.db\")\n      conn.execute(\"INSERT INTO tasks (task, done) VALUES (?, 0)\", (task,))\n      conn.commit()\n      conn.close()\n      print(f\"\ud83d\udcdd Added task: {task}\")\n\n  complete:\n    help: Mark a task as complete\n    params: [name: str!, id: int!]\n    run: |\n      conn = sqlite3.connect(f\"{name}.db\")\n      conn.execute(\"UPDATE tasks SET done = 1 WHERE id = ?\", (id,))\n      conn.commit()\n      conn.close()\n      print(f\"\ud83c\udf89 Marked task {id} as complete\")\n</code></pre> <p></p> <p>For more examples, check examples directory.</p>"},{"location":"#why-cliffy","title":"Why cliffy","text":"<ul> <li>Mix Python and shell commands naturally</li> <li>Hot-reload changes as you develop</li> <li>Package your CLI as a single executable with <code>cli build</code></li> <li>Test your CLIs with built-in test runner</li> <li>Use Jinja2 template syntax for dynamic command generation</li> <li>Reusable command templates</li> <li>AI-friendly- see the supported AI features</li> </ul> <p>Similar frameworks</p> <ul> <li>Bashly - An awesome YAML to Bash CLI builder</li> <li>Fire - Python objects to CLI builder</li> </ul>"},{"location":"features/","title":"Cliffy Features","text":"<p>Cliffy provides a wide range of features to help you build powerful and flexible command-line interfaces. This guide will explore some of the key features with examples.</p> <p>Note</p> <p>Refer to Typer docs for docs on crafting custom paramater types.</p>"},{"location":"features/#dependencies","title":"Dependencies","text":"<p>You can specify Python package dependencies for the CLI using the <code>requires</code> section. For example:</p> <pre><code>requires:\n  - tabulate&gt;=0.9.0\n</code></pre> <p>This ensures that the <code>tabulate</code> package is installed when the CLI is used. Built CLIs will automatically bundle these specified dependencies with the CLI zipapp, making it super easy to distribute CLIs.</p>"},{"location":"features/#imports","title":"Imports","text":"<p>The <code>imports</code> section allows you to import Python modules. For example:</p> <pre><code>imports: |\n  import json\n  from datetime import datetime\n  from tabulate import tabulate\n</code></pre> <p>These modules can then be used in any of your command or function definitions.</p>"},{"location":"features/#variables","title":"Variables","text":"<p>You can define variables in the <code>vars</code> section and use them throughout your manifest. For example:</p> <pre><code>vars:\n  data_file: \"tasks.json\"\n</code></pre> <p>Then, you can reference this variable using <code>{{data_file}}</code> in other parts of the manifest for dynamic injection on CLI load.</p>"},{"location":"features/#functions","title":"Functions","text":"<p>The <code>functions</code> section allows you to define helper functions that can be used in your commands. For example:</p> <pre><code>functions:\n  - |\n    def load_data():\n        try:\n            with open(\"{{data_file}}\", \"r\") as f:\n                return json.load(f)\n        except FileNotFoundError:\n            return {\"projects\": [], \"tasks\": []}\n</code></pre> <p>These functions can be used to encapsulate reusable logic.</p>"},{"location":"features/#types","title":"Types","text":"<p>You can define custom types in the <code>types</code> section and use them in your command arguments and options. For example:</p> <pre><code>types:\n  ProjectName: str = typer.Argument(..., help=\"Name of the project\")\n  TaskName: str = typer.Argument(..., help=\"Name of the task\")\n  DueDate: str = typer.Option(None, \"--due\", \"-d\", help=\"Due date (YYYY-MM-DD)\")\n  Priority: int = typer.Option(1, \"--priority\", \"-p\", help=\"Priority (1-5)\", min=1, max=5)\n</code></pre> <p>This allows you to define type annotations and help messages for your arguments and options.</p>"},{"location":"features/#commands","title":"Commands","text":"<p>The <code>commands</code> section defines the different commands that your CLI supports. For example:</p> <pre><code>commands:\n  project.add:\n    params: [name: ProjectName]\n    run: |\n      data = load_data()\n      if name not in data[\"projects\"]:\n          data[\"projects\"].append(name)\n          save_data(data)\n          print(f\"Project '{name}' added successfully.\")\n      else:\n          print(f\"Project '{name}' already exists.\")\n</code></pre> <p>This defines a nested <code>project add</code> command that takes a <code>ProjectName</code> argument.</p>"},{"location":"features/#shell-commands","title":"Shell Commands","text":"<p>You can execute shell commands using the <code>$</code> prefix in the <code>run</code> section. For example:</p> <pre><code>backup:\n  help: Create a backup of the task data\n  run: |\n    $ cp {{data_file}} {{data_file}}.backup\n    $ echo \"Backup created: {{data_file}}.backup\"\n</code></pre> <p>This allows you to integrate shell commands into your CLI. Internally, shell commands will get translated into python subprocess calls. You can always verify the generated CLI code using <code>cli render</code>.</p> <p>In special cases, you may want to trigger the unsafe <code>shell=True</code> in the subprocess calls. For those times, you can use the <code>&gt;</code> prefix instead. Beware!</p>"},{"location":"features/#global-params","title":"Global params","text":"<p>Define <code>global_params</code> to add common arguments/options across ALL commands.</p> <pre><code>global_params:\n  - name: \"--verbose\"\n    type: \"bool\"\n    default: false\n    help: \"Enable verbose output\"\n\ncommands:\n  hello:\n    run: |\n      if verbose:\n        print(\"Verbose mode enabled\")\n      print(\"Hello!\")\n  goodbye:\n    run: |\n      if verbose:\n        print(\"Verbose mode enabled\")\n      print(\"Goodbye!\")\n</code></pre> <p>When either command is executed with <code>--verbose</code>, the corresponding <code>if verbose:</code> block within the run script will be executed.</p> <p>Note how the verbose variable is available directly within the command's script. No special handling is needed. It's treated like a normal parameter.</p>"},{"location":"features/#command-templates","title":"Command Templates","text":"<p>You can define reusable command templates in the <code>command_templates</code> section. For example:</p> <pre><code>command_templates:\n  with_confirmation:\n    params:\n      - \"yes\": bool = typer.Option(False, \"--yes\", \"-y\", help=\"Skip confirmation prompt\")\n    pre_run: |\n      if not yes:\n        typer.confirm(\"Are you sure you want to proceed?\", abort=True)\n</code></pre> <p>Then, you can use this template in your commands:</p> <pre><code>commands:\n  delete|rm:\n    help: Delete a file\n    template: with_confirmation\n    params: [filename: Filename]\n    run: |\n      if verbose:\n        print(f\"Deleting {{filename}}\")\n      os.remove(filename)\n      print(\"File deleted successfully\")\n</code></pre> <p>This allows you to reuse common argument definitions and pre/post run logic across multiple commands.</p> <p>Note</p> <p>Command script execution is performed in the following order:</p> <ol> <li>Template pre-run</li> <li>Command pre-run</li> <li>Command run</li> <li>Command post-run</li> <li>Template post-run</li> </ol>"},{"location":"features/#tests","title":"Tests","text":"<p>The <code>tests</code> section allows you to define test cases for your commands. For example:</p> <pre><code>tests:\n  - project add test1: assert result.exit_code == 0\n  - project list: assert \"test1\" in result.output\n</code></pre> <p>These tests can then be run with <code>cli test</code>. </p>"},{"location":"features/#hot-reload","title":"Hot-reload","text":"<p>Use the <code>cli dev</code> command to actively monitor a manifest for changes and automatically reload. Highly recommended for CLI manifest development.</p> <p>Example</p> <ul> <li><code>cli dev examples/hello.yaml</code></li> <li><code>cli dev examples/hello.yaml --run-cli hello</code> (reload on change and run <code>hello</code> command)</li> </ul>"},{"location":"features/#ide-integration","title":"IDE Integration","text":""},{"location":"features/#schema-validation-and-autocomplete","title":"Schema validation and autocomplete","text":"<p>To get real-time feedback while developing your CLI, install the YAML extension and setup by either:</p> <p>a. Generating manifest with local json-schema: <code>cli init --json-schema</code> b. Referencing the latest remote json-schema in your manifest:</p> <pre><code># yaml-language-server: $schema=https://raw.githubusercontent.com/jaykv/cliffy/refs/heads/main/examples/cliffy_schema.json\n</code></pre>"},{"location":"features/#embedded-syntax-highlighting","title":"Embedded syntax highlighting","text":"<p>Install the YAML embedded languages extension for proper syntax-highlighting for command run scripts.</p>"},{"location":"features/#ai-features","title":"AI Features","text":"<p>Cliffy includes AI-powered commands to help you generate and understand CLI manifests. Access these features through the <code>cli ai</code> command group.</p> <p>Note</p> <p>Requires <code>cliffy[ai]</code> dependency group to be installed. See Installation</p> <p>Tip</p> <p>For a list of the models supported, see https://ai.pydantic.dev/models/. You can specify the model to use for the AI commands with <code>--model</code> or <code>-m</code> option.</p> <pre><code># Example using a specific model\nexport OPENAI_API_KEY='your-api-key'\ncli ai generate mycli \"Create a todo app\" --model gpt-4o\n</code></pre> <p>Tip</p> <p>Use <code>--preview</code> to output the fully constructed prompt for debugging or review.</p>"},{"location":"features/#manifest-generation","title":"Manifest Generation","text":"<p>Generate complete CLI manifests from natural language descriptions:</p> <pre><code>cli ai generate mycli \"Create a CLI for managing docker containers with commands to list, start, stop and remove containers\"\n</code></pre>"},{"location":"features/#interactive-help","title":"Interactive Help","text":"<p>Get AI assistance for understanding and working with cliffy:</p> <pre><code>cli ai ask \"How do I create nested subcommands?\"\n</code></pre> <p>You can also get targeted help about specific CLIs by referencing them:</p> <pre><code>cli ai ask --cli mycli.yaml \"How do I add input validation to the start command?\"\n</code></pre>"},{"location":"getting-started/","title":"Getting Started with Cliffy","text":"<p>This guide will walk you through the basics of setting up and using Cliffy to create your own CLI tools.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>To get started with Cliffy, you'll need to install it using pip:</p> <pre><code>pip install cliffy  # cliffy[ai,rich] for rich CLI and AI features\ncli --help\ncli init mycli\ncli load mycli.yaml\nmycli -h\n</code></pre> <p>You can also use uv to run cliffy directly with: <pre><code>uvx --with \"cliffy[rich,ai]\" cliffy --help\nuvx cliffy init mycli\nuvx cliffy load mycli.yaml\nuvx --from cliffy mycli -h\n</code></pre></p> <p>Tip</p> <p>Alternative setup for cliffy + uv with ai and rich groups. <pre><code>uv venv\nuv pip install \"cliffy[ai,rich]\"\nuv run cli -h\nuv run cli init mycli\nuv run cli load mycli.yaml\nuv run mycli -h\n</code></pre></p>"},{"location":"getting-started/#creating-your-first-cli","title":"Creating Your First CLI","text":"<p>Let's create a simple \"hello\" CLI with <code>$ cli init hello --raw</code>.</p> <p>You should now have a hello.yaml file. Open it and replace the manifest with:</p> <pre><code>name: hello\nversion: 0.1.0\nhelp: A simple CLI that greets the user.\n\ncommands:\n  hello:\n    help: Greet the user\n    params:\n      - name: str = typer.Option(\"World\", \"--name\", \"-n\", help=\"Name to greet\")\n    run: |\n      print(f\"Hello, {name}!\")\n</code></pre> <p>This manifest defines a CLI named <code>hello</code> with a single command <code>hello</code> that takes an optional <code>--name</code> argument.</p>"},{"location":"getting-started/#running-your-cli","title":"Running Your CLI","text":"<p>To run your CLI, use the <code>cli run</code> command followed by the path to your manifest file:</p> <pre><code>cli run hello.yaml -- hello --name \"Your Name\"\n</code></pre> <p>This will output:</p> <pre><code>Hello, Your Name!\n</code></pre>"},{"location":"getting-started/#loading-clis","title":"Loading CLIs","text":"<p>You can load the CLI using the <code>cli load</code> command to avoid needing to prefix <code>cli run hello.yaml</code> for each trigger:</p> <pre><code>cli load hello.yaml\n</code></pre> <p>This command loads the generated CLI into the current Python environment. You can then run the CLI directly from the terminal by its name:</p> <pre><code>hello -h\n</code></pre>"},{"location":"getting-started/#building-clis","title":"Building CLIs","text":"<p>To build a CLI into a portable zipapp, you can run the <code>cli build</code> command:</p> <pre><code>cli build hello.yaml -o dist\n</code></pre> <p>This command builds a portable zipapp containing the CLI and its package requirements, outputting it to the <code>dist</code> directory. You can then run the built CLI:</p> <pre><code>./dist/hello -h\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>This is just a basic example. Cliffy supports many more features, such as:</p> <ul> <li>Defining types for arguments and options.</li> <li>Using variables and functions in your manifest.</li> <li>Creating complex command structures.</li> <li>Running shell commands.</li> <li>Testing your CLI.</li> </ul> <p>Explore the Features section to learn more about these capabilities.</p>"},{"location":"schema/","title":"CLI Manifest Schema","text":"<p>This document describes the schema for the CLI manifest.</p>"},{"location":"schema/#climanifest","title":"CLIManifest","text":"<p>The <code>CLIManifest</code> model defines the structure of a CLI manifest file. It includes fields for the CLI's name, version, dependencies, commands, and other configuration options.</p>"},{"location":"schema/#fields","title":"Fields","text":"<ul> <li><code>manifestVersion</code>: The version of the manifest schema.</li> <li><code>name</code>: The name of the CLI, used when invoking from the command line.</li> <li><code>version</code>: The CLI version.</li> <li><code>help</code>: A brief description of the CLI.</li> <li><code>requires</code>: A list of Python package dependencies for the CLI. Supports requirements specifier syntax.</li> <li><code>includes</code>: A list of external CLI manifests to include. Performs a deep merge of manifests sequentially in the order given to assemble a merged manifest, and finally, deep merges the merged manifest with this manifest.</li> <li><code>vars</code>: A mapping defining manifest variables that can be referenced in any other blocks. Environments variables can be used in this section with <code>${some_env_var}</code> for dynamic parsing. Supports jinja2 formatted expressions as values. Interpolate defined vars in other blocks jinja2-styled <code>{{ var_name }}</code>.</li> <li><code>imports</code>: A string block or list of strings containing any module imports. These can be used to import any python modules that the CLI depends on.</li> <li><code>functions</code>: A string block or list of helper function definitions. These functions should be defined as strings that can be executed by the Python interpreter.</li> <li><code>types</code>: A mapping containing any shared type definitions. These types can be referenced by name in the args section to provide type annotations for params and options defined in the args section.</li> <li><code>global_params</code>: Parameters applied to all commands.</li> <li><code>command_templates</code>: Reusable command templates.</li> <li><code>commands</code>: A mapping containing the command definitions for the CLI. Each command should have a unique key- which can be either a group command or nested subcommands. Nested subcommands are joined by '.' in between each level. Aliases for commands can be separated in the key by '|'. A special '(*)' wildcard can be used to spread the subcommand to all group-level commands.</li> <li><code>cli_options</code>: Additional CLI configuration options.</li> <li><code>tests</code>: Test cases for commands.</li> </ul>"},{"location":"schema/#command","title":"Command","text":"<p>The <code>Command</code> model defines a single command within the CLI. It specifies the command's execution logic, arguments, and configuration.</p>"},{"location":"schema/#fields_1","title":"Fields","text":"<ul> <li><code>run</code>: The command's execution logic, defined as a <code>RunBlock</code>. Can be a single command or a list of commands.</li> <li><code>help</code>: A description of the command.</li> <li><code>args</code>: A list of arguments for the command. Each argument can be:<ul> <li>A <code>SimpleCommandParam</code>: <code>{'name': 'str = \"tester\"'}</code> structure</li> <li>A <code>CommandParam</code>: Full argument specification</li> <li>A string: Type annotation string</li> </ul> </li> <li><code>template</code>: A reference to a command template.</li> <li><code>pre_run</code>: A <code>PreRunBlock</code> to execute before the command.</li> <li><code>post_run</code>: A <code>PostRunBlock</code> to execute after the command.</li> <li><code>aliases</code>: A list of aliases for the command.</li> <li><code>name</code>: The name of the command.</li> <li><code>config</code>: An optional <code>CommandConfig</code> object.</li> </ul>"},{"location":"schema/#commandparam","title":"CommandParam","text":"<p>The <code>CommandParam</code> model defines the structure of a command parameter.</p>"},{"location":"schema/#fields_2","title":"Fields","text":"<ul> <li><code>name</code>: The name of the parameter. Options must be prefixed with <code>--</code>.</li> <li><code>type</code>: The type of the argument (e.g., <code>str</code>, <code>int</code>, <code>bool</code>).</li> <li><code>default</code>: The default value.</li> <li><code>help</code>: Description of the argument.</li> <li><code>short</code>: Short alias (only valid when name is prefixed with <code>--</code> as an option/flag).</li> <li><code>required</code>: Whether the argument is required.</li> </ul>"},{"location":"schema/#runblock-types","title":"RunBlock Types","text":"<p>Commands now use specialized blocks for execution:</p> <ul> <li><code>RunBlock</code>: Main command execution block</li> <li><code>PreRunBlock</code>: Pre-execution hook</li> <li><code>PostRunBlock</code>: Post-execution hook</li> <li><code>RunBlockList</code>: List of execution blocks</li> </ul> <p>Example</p> <pre><code>commands:\n    deploy:\n        pre_run: |\n            if not confirm_deployment():\n                raise typer.Abort()\n        run:\n        - print(\"Starting deployment...\")\n        - deploy_application()\n        post_run: |\n            notify_team(\"Deployment completed\")\n</code></pre>"},{"location":"schema/#commandconfig","title":"CommandConfig","text":"<p>The <code>CommandConfig</code> model provides additional configuration options for a command.</p>"},{"location":"schema/#fields_3","title":"Fields","text":"<p>These directly correlate with params accepted by Typer <code>@app.command()</code></p> <ul> <li><code>context_settings</code>: Additional context settings for the command.</li> <li><code>epilog</code>: Text to display after the help message.</li> <li><code>short_help</code>: A short description of the command.</li> <li><code>options_metavar</code>: The metavar to use for options in the help message.</li> <li><code>add_help_option</code>: Whether to add a help option to the command.</li> <li><code>no_args_is_help</code>: Whether to display the help message if no arguments are provided.</li> <li><code>hidden</code>: Whether to hide the command from the help message.</li> <li><code>deprecated</code>: Whether the command is deprecated.</li> <li><code>rich_help_panel</code>: An optional panel name for rich help output.</li> </ul> <p>For a deeper dive, check out the manifest.py.</p>"}]}